<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1" />
  <meta name="theme-color" content="#111111" />
  <link rel="manifest" href="manifest.json" />
  <title>Notebook（v1.0.7e 最新在上＋點卡即編輯）</title>
  <style>
    :root {
      --bg:#f4f1e8;
      --bg-top:#f8f5ec;
      --fg:#1c1c1e;
      --muted:#6c6c70;
      --card:#fffdf6;
      --card-line:rgba(0,0,0,0.04);
      --border:rgba(0,0,0,0.08);
      --danger:#ff3b30;
      --ok:#34c759;
      --accent:#ffcc00;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-family: 'SF Pro Text', -apple-system, BlinkMacSystemFont,'PingFang TC','Noto Sans TC',system-ui,sans-serif; }
    html, body { margin:0; padding:0; height:100%; color:var(--fg); background:linear-gradient(to bottom, var(--bg-top), var(--bg)); }
    body { touch-action: manipulation; }
    header {
      position:sticky;
      top:0;
      z-index:10;
      padding:14px 18px 12px;
      border-bottom:1px solid rgba(0,0,0,0.04);
      background:linear-gradient(to bottom, rgba(248,245,236,0.92), rgba(244,241,232,0.92));
      backdrop-filter: blur(18px);
    }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    .logo { font-weight:800; font-size:20px; letter-spacing:0.04em; }
    .chip { font-size:12px; padding:4px 11px; border-radius:999px; background:rgba(0,0,0,0.05); color:var(--muted); }
    input, textarea { width:100%; background:#fffdf7; color:var(--fg); border:1px solid rgba(0,0,0,0.05); padding:12px 16px; border-radius:16px; box-shadow: inset 0 1px 0 rgba(255,255,255,0.9); }
    input::placeholder, textarea::placeholder { color:#b7b7c2; }
    textarea { font-size:17px; line-height:1.68; min-height:220px; background-image: linear-gradient(to bottom, var(--card-line) 1px, transparent 1px); background-size: 100% 36px; }
    button { position:relative; overflow:hidden; background:#fffdfa; color:var(--fg); border:1px solid rgba(0,0,0,0.05); padding:10px 18px; border-radius:16px; font-weight:600; transition:transform .08s ease, box-shadow .2s ease; box-shadow:0 3px 8px rgba(0,0,0,0.08); }
    button:active { transform: scale(0.97); box-shadow:0 0 0 rgba(0,0,0,0.1); }
    button[disabled] { opacity:0.5; pointer-events:none; }
    #btnAuto[data-on="0"] { background:rgba(0,0,0,0.06); color:var(--muted); box-shadow:none; }
    .ripple { position:absolute; border-radius:50%; width:8px; height:8px; transform: translate(-50%,-50%); pointer-events:none; animation:ripple .5s ease-out; background:rgba(255,255,255,.25); }
    @keyframes ripple { from { opacity:1; width:0; height:0; } to { opacity:0; width:200px; height:200px; } }
    main { padding:18px 14px 22vh; max-width:860px; margin:0 auto; }
    .note {
      position:relative;
      background:var(--card);
      border-radius:22px;
      padding:18px 18px 20px;
      margin:12px 6px;
      display:flex;
      gap:14px;
      box-shadow:0 18px 36px rgba(0,0,0,0.08);
      border:1px solid rgba(255,255,255,0.6);
      overflow:hidden;
    }
    .note::before {
      content:"";
      position:absolute;
      inset:0;
      background-image: repeating-linear-gradient(to bottom, transparent 0 30px, var(--card-line) 30px 31px);
      opacity:0.55;
      pointer-events:none;
    }
    .note::after {
      content:"";
      position:absolute;
      top:0;
      left:0;
      right:0;
      height:12px;
      background:linear-gradient(to bottom, rgba(255,255,255,0.8), rgba(255,255,255,0));
      pointer-events:none;
    }
    .note:hover { transform: translateY(-2px); box-shadow:0 20px 40px rgba(0,0,0,0.12); }
    .note-body { flex:1; min-width:0; position:relative; z-index:1; }
    .title { display:-webkit-box; -webkit-line-clamp:2; -webkit-box-orient:vertical; overflow:hidden; word-break:break-word; font-weight:700; font-size:18px; line-height:1.34; letter-spacing:0.02em; }
    .meta { color:var(--muted); font-size:13px; margin-top:6px; display:-webkit-box; -webkit-line-clamp:1; -webkit-box-orient:vertical; overflow:hidden; }
    .actions { display:flex; flex-direction:column; gap:6px; position:relative; z-index:1; align-items:flex-end; }
    .actions button.more { width:36px; height:36px; border-radius:18px; padding:0; font-size:18px; font-weight:700; letter-spacing:0; }
    .actions button.more::after { content:'⋯'; }
    .empty { color:var(--muted); text-align:center; margin-top:32px; font-size:15px; }
    .fab { position:fixed; right:20px; bottom:24px; background:var(--accent); color:#3a2f00; border:0; border-radius:18px; padding:16px 20px; box-shadow: 0 20px 36px rgba(255,204,0,0.45); font-weight:700; letter-spacing:0.03em; z-index:20; }
    .fab span { font-size:15px; letter-spacing:0.03em; }
    dialog:not(.sheet) { width:min(720px, 96vw); max-height:90vh; background:var(--card); color:var(--fg); border:1px solid rgba(0,0,0,0.06); border-radius:32px; padding:0; box-shadow:0 28px 64px rgba(0,0,0,0.22); overflow:hidden; display:flex; flex-direction:column; }
    dialog:not(.sheet)::backdrop { background:rgba(28,28,30,0.4); backdrop-filter: blur(8px); }
    .dlg-head { padding:16px 20px; border-bottom:1px solid rgba(0,0,0,0.05); font-weight:700; display:flex; align-items:center; justify-content:space-between; gap:8px; background:#fbf8ef; letter-spacing:0.02em; }
    .dlg-body { padding:20px 22px; display:flex; flex-direction:column; gap:16px; overflow:auto; background:linear-gradient(to bottom, rgba(255,255,255,0.92), rgba(255,255,255,0.86)); }
    .dlg-foot { display:flex; gap:10px; justify-content:flex-end; padding:14px 20px; border-top:1px solid rgba(0,0,0,0.05); background:#fbf8ef; }
    .dlg-foot button:first-child { margin-right:auto; }
    .status { font-size:12px; color:#9aa0a6; min-height:1.2em; letter-spacing:0.02em; }
    .status.ok { color:var(--ok); }
    .status.err { color:var(--danger); }
    dialog.sheet { border:0; width:min(420px, 92vw); max-width:420px; padding:0; background:transparent; box-shadow:none; align-self:center; margin:auto auto max(16px, env(safe-area-inset-bottom)); }
    dialog.sheet::backdrop { background:rgba(28,28,30,0.35); backdrop-filter: blur(10px); }
    dialog.sheet .sheet-group { margin:0 12px 12px; background:rgba(255,255,255,0.96); border-radius:18px; overflow:hidden; box-shadow:0 20px 40px rgba(0,0,0,0.18); backdrop-filter: blur(20px); display:flex; flex-direction:column; }
    dialog.sheet .sheet-group:first-of-type { margin-top:18px; }
    dialog.sheet button { width:100%; border:0; border-radius:0; background:transparent; box-shadow:none; font-size:17px; padding:16px; letter-spacing:0.02em; color:var(--fg); }
    dialog.sheet button + button { border-top:1px solid rgba(0,0,0,0.08); }
    dialog.sheet button.danger { color:var(--danger); font-weight:700; }
    .toast { position:fixed; left:50%; bottom:22px; transform:translateX(-50%); background:#2f2f30; color:#fff; border:0; padding:12px 18px; border-radius:999px; opacity:0; pointer-events:none; transition:opacity .2s, transform .2s; box-shadow:0 12px 40px rgba(0,0,0,0.18); letter-spacing:0.02em; }
    .toast.show { opacity:1; transform:translateX(-50%) translateY(-6px); }
    @media (max-width:640px){
      header { padding:12px 16px 10px; }
      .note { margin:10px 0; padding:16px; border-radius:20px; }
      .note::before { background-image: repeating-linear-gradient(to bottom, transparent 0 28px, var(--card-line) 28px 29px); }
      .actions { flex-direction:row; }
      dialog:not(.sheet) { width:100vw; max-width:none; height:96vh; border-radius:36px 36px 0 0; }
      .dlg-head { border-bottom:0; border-top-left-radius:36px; border-top-right-radius:36px; }
      .dlg-foot { border-top:0; }
    }
  </style>
</head>
<body>
  <header>
    <div class="row">
      <div class="logo">備忘錄</div>
      <span class="chip">左緣→右滑：上一頁</span>
      <span class="chip" id="count">0 筆</span>
      <span class="chip" id="lastSync">尚未更新</span>
      <button id="btnRefresh" style="margin-left:auto">更新</button>
      <button id="btnAuto" data-on="1">即時更新中</button>
    </div>
    <div class="row" style="margin-top:6px">
      <input id="q" placeholder="搜尋標題或內容…" />
      <button id="btnSearch">搜尋</button>
      <button id="btnClear">清空</button>
    </div>
  </header>

  <main id="list"></main>
  <div id="error" class="err"></div>

  <button class="fab" id="btnNew"><span>＋ 新增</span></button>

  <!-- 編輯視窗（同時用於新增與修改） -->
  <dialog id="dlgEdit">
    <div class="dlg-head" id="dlgTitle">筆記</div>
    <div class="dlg-body">
      <input id="fTitle" placeholder="標題" />
      <textarea id="fContent" rows="8" placeholder="內容（點卡即編輯，就像備忘錄）"></textarea>
      <div class="status" id="autoMeta" aria-live="polite"></div>
      <input id="fCategory" placeholder="分類" />
      <input id="fTags" placeholder="標籤（以逗號分隔）" />
      <input id="fDate" placeholder="日期（自動）" disabled />
      <div id="statusEdit" class="status"></div>
    </div>
    <div class="dlg-foot">
      <button id="btnDelete" style="display:none">刪除</button>
      <button id="btnCancelEdit">關閉</button>
      <button id="btnSaveEdit">儲存</button>
    </div>
  </dialog>

  <div id="toast" class="toast">已完成</div>

  <dialog id="dlgActions" class="sheet">
    <div class="sheet-group">
      <button type="button" id="btnActionEdit">檢視／編輯</button>
      <button type="button" id="btnActionDelete" class="danger">刪除</button>
    </div>
    <div class="sheet-group">
      <button type="button" id="btnActionCancel">取消</button>
    </div>
  </dialog>

  <script type="module">
  import {
    normalizeList,
    normalizeItem,
    anyId,
    parseDateNum,
    fmtDate,
    nowSheetStr,
    extractMetaFromContent,
  } from './scripts/notebook-utils.js';

  const API = "https://script.google.com/macros/s/AKfycbx3oTDF49EmwGp5ZgGs9WIO64m7UzVzj5IDcBmm222aR7eTQTG8DXUsYVGVnzH2ga4abQ/exec";
  const ACT = { list:'列出筆記', get:'取得筆記', create:'新增筆記', update:'修改筆記', delete:'刪除筆記' };
  const ACT_FALLBACK = { list:'listNotes', get:'getNote', create:'createNote', update:'updateNote', delete:'deleteNote' };
  const KEY = { title:'標題', content:'內容', category:'分類', tags:'標籤', date:'日期', id:'id' };
  const lastSync = document.getElementById('lastSync');

  document.body.addEventListener('click', e=>{
    const btn=e.target.closest('button'); if(!btn) return;
    const r=document.createElement('span'); r.className='ripple';
    const rect=btn.getBoundingClientRect(); r.style.left=(e.clientX-rect.left)+'px'; r.style.top=(e.clientY-rect.top)+'px';
    btn.appendChild(r); setTimeout(()=> r.remove(), 500);
  });

  function clearErr(){ error.textContent=''; }
  function showErr(msg, raw){ error.textContent = '⚠️ ' + msg + (raw ? ('\n' + raw) : ''); }
  function toast(msg){ const t=document.getElementById('toast'); t.textContent=msg||'已完成'; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1200); }
  function setStatus(el, msg, ok=false, err=false){ el.textContent=msg||''; el.classList.toggle('ok', !!ok); el.classList.toggle('err', !!err); }
  function updateLastSyncLabel(){
    if (!lastSync) return;
    if (!lastLoadedAt){ lastSync.textContent = '尚未更新'; return; }
    const diff = Date.now() - lastLoadedAt;
    if (diff < 15000) { lastSync.textContent = '剛剛同步'; return; }
    if (diff < 60000) { lastSync.textContent = '不到 1 分鐘前'; return; }
    if (diff < 3600000) { lastSync.textContent = `約 ${Math.floor(diff/60000)} 分鐘前`; return; }
    lastSync.textContent = '最後更新：' + new Date(lastLoadedAt).toLocaleString('zh-TW', { hour12: false });
  }
  function ensureLastSyncTimer(){
    if (lastSyncTimer) return;
    lastSyncTimer = setInterval(updateLastSyncLabel, 15000);
  }
  function setLoading(loading, silent=false){
    if (loading){
      loadingCount++;
      btnRefresh.disabled = true;
      btnRefresh.textContent = silent ? '背景更新…' : '更新中…';
      if (lastSync) lastSync.textContent = silent ? '背景更新中…' : '更新中…';
      return;
    }
    if (loadingCount > 0) loadingCount--;
    if (loadingCount > 0) return;
    btnRefresh.disabled = false;
    btnRefresh.textContent = '更新';
    updateLastSyncLabel();
  }
  function applyFallbackParams(url, actionLabel) {
    if (!url.searchParams.has('op') && actionLabel) {
      const fallback = Object.entries(ACT).find(([, label]) => label === actionLabel);
      if (fallback) {
        const key = fallback[0];
        const alt = ACT_FALLBACK[key];
        if (alt) {
          url.searchParams.set('op', alt);
          url.searchParams.set('method', alt);
        }
      }
    }
  }
  function handleParsedResponse(parsed, { silent } = {}) {
    if (!parsed || typeof parsed !== 'object') return parsed;
    if (parsed.ok === false && !silent) {
      const msg = parsed.error || parsed.message || '操作失敗，請稍後再試';
      showErr(msg);
    }
    return parsed;
  }
  async function getJson(params, options={}){
    if (!options.silent) clearErr();
    const url = new URL(API);
    Object.entries(params).forEach(([k,v])=> url.searchParams.set(k, v));
    applyFallbackParams(url, params.action);
    const res = await fetch(url.toString(), { method:'GET', signal: options.signal, mode:'cors' });
    if (!res.ok) {
      const text = await res.text().catch(()=> '');
      throw new Error(text || `HTTP ${res.status}`);
    }
    const raw = await res.text();
    try {
      return handleParsedResponse(JSON.parse(raw), options);
    } catch(e){
      if (options.silent) return { error:'not_json', raw };
      showErr('後端不是 JSON：', raw);
      return { error:'not_json', raw };
    }
  }
  async function postJson(action, bodyObj){
    clearErr();
    const url = new URL(API);
    url.searchParams.set('action', action);
    applyFallbackParams(url, action);
    const res = await fetch(url.toString(), {
      method:'POST',
      mode:'cors',
      headers:{ 'Content-Type':'application/json;charset=UTF-8' },
      body: JSON.stringify(bodyObj||{})
    });
    if (!res.ok) {
      const text = await res.text().catch(()=> '');
      throw new Error(text || `HTTP ${res.status}`);
    }
    const raw = await res.text();
    try {
      return handleParsedResponse(JSON.parse(raw));
    } catch(e){
      showErr('後端不是 JSON：', raw);
      return { error:'not_json', raw };
    }
  }

  let notes = [];
  let editingId = null;
  let autoTimer = null;
  let autoEnabled = true;
  let lastRenderKey = '';
  let listAbort = null;
  let lastLoadedAt = null;
  let lastSyncTimer = null;
  let loadingCount = 0;
  let manualTitle = false;
  let manualCategory = false;
  let manualTags = false;
  let actionIdx = null;

  const AUTO_INTERVAL = 3000;

  async function loadList(keyword='', silent=false) {
    if (listAbort) listAbort.abort();
    const controller = new AbortController();
    listAbort = controller;
    setLoading(true, silent);
    try {
      const response = await getJson({ action: ACT.list, keyword, q: keyword, limit: 500 }, { signal: controller.signal, silent });
      if (controller.signal.aborted) return;
      if (response && response.ok === false) {
        notes = [];
        renderList();
        return;
      }
      const listSource = response && typeof response === 'object' && 'data' in response ? response.data : response;
      notes = normalizeList(listSource);
      if (!Array.isArray(notes)) notes = [];
      notes.sort((a,b)=> (parseDateNum(b[KEY.date] ?? b.date) - parseDateNum(a[KEY.date] ?? a.date)) );
      const renderKey = JSON.stringify(notes.map(n=>({
        id: anyId(n),
        t: n[KEY.title] ?? n.title ?? '',
        d: n[KEY.date] ?? n.date ?? '',
        c: n[KEY.category] ?? n.category ?? '',
        g: n[KEY.tags] ?? n.tags ?? ''
      })));
      if (renderKey === lastRenderKey) {
        lastLoadedAt = Date.now();
        ensureLastSyncTimer();
        updateLastSyncLabel();
        return;
      }
      lastRenderKey = renderKey;
      lastLoadedAt = Date.now();
      ensureLastSyncTimer();
      updateLastSyncLabel();
      renderList();
    } catch(err) {
      if (err?.name === 'AbortError') return;
      if (!silent) showErr('載入失敗，請稍後再試', err?.message || err);
    } finally {
      if (listAbort === controller) listAbort = null;
      setLoading(false);
    }
  }

  function renderList() {
    const el = document.getElementById('list');
    el.innerHTML = '';
    const count = notes.length || 0;
    document.getElementById('count').textContent = count + ' 筆';
    if (!count) { el.innerHTML = '<div class="empty">沒有資料</div>'; return; }
    notes.forEach((n, idx)=> {
      const title = n[KEY.title] ?? n.title ?? '(無標題)';
      const date  = fmtDate(n[KEY.date] ?? n.date ?? '');
      const cat   = n[KEY.category] ?? n.category ?? '';
      const tags  = n[KEY.tags] ?? n.tags ?? '';
      const id    = anyId(n);
      const card = document.createElement('div');
      card.className = 'note';
      card.innerHTML = `
        <div class="note-body" data-edit="${idx}">
          <div class="title">${title}</div>
          <div class="meta">${date}${cat?' · '+cat:''}${tags?' · '+tags:''}</div>
        </div>
        <div class="actions">
          <button type="button" class="more" data-actions="${idx}" aria-label="更多"></button>
        </div>`;
      el.appendChild(card);
    });
  }

  list.addEventListener('click', async (e)=> {
    const open = e.target.closest('[data-edit]');
    const btn = e.target.closest('button');
    if (open) {
      const idx = parseInt(open.getAttribute('data-edit'), 10);
      await openNoteByIndex(idx);
      return;
    }
    if (btn && btn.classList.contains('more')) {
      const idx = parseInt(btn.getAttribute('data-actions'), 10);
      if (Number.isNaN(idx)) return;
      actionIdx = idx;
      dlgActions.showModal();
    }
  });

  const dlgEdit = document.getElementById('dlgEdit');
  const dlgActions = document.getElementById('dlgActions');
  const btnActionEdit = document.getElementById('btnActionEdit');
  const btnActionDelete = document.getElementById('btnActionDelete');
  const btnActionCancel = document.getElementById('btnActionCancel');

  function resetEditorState() {
    fTitle.value = '';
    fContent.value = '';
    fCategory.value = '';
    fTags.value = '';
    fDate.value = '';
    setStatus(statusEdit, '');
    editingId = null;
    manualTitle = false;
    manualCategory = false;
    manualTags = false;
    autoMeta.textContent = '';
  }

  function closeEditor() {
    if (dlgEdit.open) dlgEdit.close();
    resetEditorState();
  }

  function updateAutoMeta(fromUserInput=false) {
    const meta = extractMetaFromContent(fContent.value);
    autoMeta.textContent = `標題：${meta.autoTitle}${meta.category ? ` ｜ 分類：${meta.category}` : ''}${meta.tags ? ` ｜ 標籤：${meta.tags}` : ''}`;
    if (!manualTitle) {
      if (meta.title) {
        fTitle.value = meta.title;
      } else if (!fTitle.value) {
        fTitle.value = '';
      }
    }
    if (!manualCategory) {
      if (meta.category) {
        fCategory.value = meta.category;
      } else if (!fCategory.value.trim()) {
        fCategory.value = '';
      }
    }
    if (!manualTags) {
      if (meta.tags) {
        fTags.value = meta.tags;
      } else if (!fTags.value.trim()) {
        fTags.value = '';
      }
    }
    return meta;
  }

  function openEditor(item=null) {
    if (dlgEdit.open) dlgEdit.close();
    resetEditorState();
    editingId = item ? (anyId(item) ?? null) : null;
    document.getElementById('dlgTitle').textContent = editingId ? '編輯筆記' : '新增筆記';
    fTitle.value    = item?.[KEY.title]    ?? item?.title   ?? '';
    fContent.value  = item?.[KEY.content]  ?? item?.content ?? '';
    fCategory.value = item?.[KEY.category] ?? item?.category?? '';
    fTags.value     = item?.[KEY.tags]     ?? item?.tags    ?? '';
    fDate.value     = fmtDate(item?.[KEY.date] ?? item?.date ?? '');
    setStatus(statusEdit, '');
    btnDelete.style.display = editingId ? '' : 'none';
    dlgEdit.showModal();
    updateAutoMeta();
    setTimeout(()=> fContent.focus(), 0);
  }
  btnCancelEdit.addEventListener('click', ()=> { closeEditor(); });
  fContent.addEventListener('input', ()=> updateAutoMeta(true));
  fTitle.addEventListener('input', ()=> { manualTitle = !!fTitle.value.trim(); updateAutoMeta(true); });
  fCategory.addEventListener('input', ()=> { manualCategory = !!fCategory.value.trim(); });
  fTags.addEventListener('input', ()=> { manualTags = !!fTags.value.trim(); });
  btnSaveEdit.addEventListener('click', async ()=> {
    const meta = updateAutoMeta(true);
    const titleInput = (fTitle.value||'').trim();
    const finalTitle = titleInput || meta.autoTitle;
    const finalCategory = (fCategory.value||'').trim() || meta.category || '';
    const finalTags = (fTags.value||'').trim() || meta.tags || '';
    const finalContent = fContent.value;
    const basePayload = {
      '標題': finalTitle,
      '分類': finalCategory,
      '標籤': finalTags,
      '內容': finalContent,
    };
    const compatPayload = {
      title: finalTitle,
      category: finalCategory,
      tags: finalTags,
      content: finalContent,
    };
    try {
      setStatus(statusEdit, '儲存中…');
      let action = ACT.update;
      let payload;
      if (editingId) {
        payload = Object.assign({ id: editingId }, basePayload, compatPayload);
      } else {
        const nowStr = nowSheetStr();
        action = ACT.create;
        payload = Object.assign({ '日期': nowStr, date: nowStr, Date: nowStr }, basePayload, compatPayload);
      }
      const result = await postJson(action, payload);
      if (result && result.ok === false) {
        const message = result.message || result.error || '儲存失敗，請稍後再試';
        setStatus(statusEdit, message, false, true);
        return;
      }
      if (result && (result.error || result.success === false || result.result === 'error')) {
        const message = result.message || result.error || '儲存失敗，請稍後再試';
        setStatus(statusEdit, message, false, true);
        return;
      }
      toast('已儲存');
      closeEditor();
      await loadList(q.value.trim());
    } catch(err) {
      setStatus(statusEdit, err?.message || '儲存失敗，請檢查網路後再試', false, true);
    }
  });
  btnDelete.addEventListener('click', async ()=> {
    if (!editingId) { setStatus(statusEdit,'缺少 id，無法刪除',false,true); return; }
    if (!confirm('確定要刪除？（將搬到回收）')) return;
    await deleteById(editingId, { fromEditor: true });
  });

  btnNew.addEventListener('click', ()=> openEditor(null));
  btnRefresh.addEventListener('click', ()=> loadList(q.value.trim()));
  btnAuto.addEventListener('click', ()=> {
    autoEnabled = !autoEnabled;
    btnAuto.dataset.on = autoEnabled ? '1' : '0';
    btnAuto.textContent = autoEnabled ? '即時更新中' : '已暫停即時更新';
    startAuto();
    if (autoEnabled) loadList(q.value.trim(), true);
  });
  q.addEventListener('keydown', e=> { if (e.key==='Enter') btnSearch.click(); });
  btnSearch.addEventListener('click', ()=> loadList(q.value.trim()));
  btnClear.addEventListener('click', ()=> { q.value=''; loadList(''); });

  function startAuto() {
    if (autoTimer) { clearInterval(autoTimer); autoTimer = null; }
    if (!autoEnabled) return;
    autoTimer = setInterval(()=> loadList(q.value.trim(), true), AUTO_INTERVAL);
  }

  async function openNoteByIndex(idx) {
    const n = notes[idx]; if (!n) return;
    const id = anyId(n);
    const params = { action: ACT.get };
    if (id != null) {
      params.id = id;
      params.ID = id;
      params.noteId = id;
      const idNum = Number(id);
      if (!Number.isNaN(idNum)) {
        params.idNumber = idNum;
        params.noteIdNumber = idNum;
      }
    }
    const resp = await getJson(params);
    if (resp && resp.ok === false) return;
    const source = resp && typeof resp === 'object' && 'data' in resp ? resp.data : resp;
    const item = normalizeItem(source) || {};
    if (anyId(item) == null) {
      if (id != null) item.id = id;
      if (id != null) item.ID = id;
    }
    openEditor(item);
  }

  async function deleteById(id, options={}) {
    if (!id) { showErr('缺少 id，無法刪除'); return; }
    try {
      if (options.fromEditor) {
        setStatus(statusEdit, '刪除中…');
      }
      const idNum = Number(id);
      const idPayload = { id, ID: id, noteId: id, 筆記ID: id };
      if (!Number.isNaN(idNum)) {
        idPayload.idNumber = idNum;
        idPayload.noteIdNumber = idNum;
        idPayload.IDNumber = idNum;
      }
      const result = await postJson(ACT.delete, idPayload);
      if (result && result.ok === false) {
        const message = result.message || result.error || '刪除失敗，請稍後再試';
        if (options.fromEditor) setStatus(statusEdit, message, false, true); else showErr(message);
        return;
      }
      if (result && (result.error || result.success === false || result.result === 'error')) {
        const message = result.message || result.error || '刪除失敗，請稍後再試';
        if (options.fromEditor) setStatus(statusEdit, message, false, true); else showErr(message);
        return;
      }
      toast('已刪除');
      if (options.fromEditor) closeEditor();
      await loadList(q.value.trim());
    } catch(err) {
      const message = err?.message || '刪除失敗，請檢查網路後再試';
      if (options.fromEditor) setStatus(statusEdit, message, false, true); else showErr(message);
    } finally {
      if (!options.fromEditor) closeActions();
    }
  }

  function closeActions() {
    if (dlgActions.open) dlgActions.close();
    actionIdx = null;
  }

  dlgActions.addEventListener('cancel', ()=> closeActions());
  dlgActions.addEventListener('click', (e)=> {
    if (e.target === dlgActions) closeActions();
  });
  btnActionCancel.addEventListener('click', ()=> closeActions());
  btnActionEdit.addEventListener('click', async ()=> {
    if (actionIdx == null) return;
    const idx = actionIdx;
    closeActions();
    await openNoteByIndex(idx);
  });
  btnActionDelete.addEventListener('click', async ()=> {
    if (actionIdx == null) return;
    const note = notes[actionIdx];
    const id = anyId(note);
    closeActions();
    if (!id) { showErr('找不到這筆的識別碼（id）'); return; }
    if (!confirm('確定要刪除？（將搬到回收）')) return;
    await deleteById(id);
  });

  let startX=0, startY=0, moved=false, lastTouchEnd=0;
  window.addEventListener('touchstart', (e)=> { const t=e.touches[0]; startX=t.clientX; startY=t.clientY; moved=false; }, {passive:true});
  window.addEventListener('touchmove', ()=> { moved=true; }, {passive:true});
  window.addEventListener('touchend', (e)=> {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) { e.preventDefault(); }
    lastTouchEnd = now;
    if (!moved) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - startX;
    const dy = Math.abs(t.clientY - startY);
    if (dx > 80 && dy < 50 && startX < 80) history.back();
  }, {passive:false});
  window.addEventListener('gesturestart', e=> { e.preventDefault(); }, {passive:false});

  window.addEventListener('load', ()=> {
    if ('serviceWorker' in navigator) try { navigator.serviceWorker.register('./sw.js'); } catch(e){}
    loadList(''); startAuto();
  });
  </script>
</body>
</html>
